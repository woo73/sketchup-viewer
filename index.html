<!DOCTYPE html>
<html>
    <div style="position: fixed; top: 150px; left: 10px; z-index: 100; background: rgba(0,0,0,0.7); padding: 10px; border-radius: 5px;">
        <input type="file" id="modelUpload" accept=".glb,.gltf" style="display: none;" onchange="loadNewModel(this.files[0])">
        <label for="modelUpload" style="color: white; cursor: pointer;">ğŸ“¤ ä¸Šä¼ æ–°æ¨¡å‹</label>
        <div id="upload-status" style="color: #aaa; font-size: 12px; margin-top: 5px;"></div>
    </div>
    <!-- ä¿¡æ¯å±•ç¤ºæ¡† -->
    <div id="info-panel" style="
    position: fixed;
    top: 20px;
    right: 20px;
    background: rgba(0,0,0,0.7);
    color: white;
    padding: 15px;
    border-radius: 5px;
    max-width: 300px;
    display: none; /* é»˜è®¤éšè— */
    z-index: 100;
">
    <h3 style="margin:0 0 10px 0;">ç‰©ä½“ä¿¡æ¯</h3>
    <div id="info-content"></div>
</div>
    <div id="measureResult" style="position: fixed; top: 500px; left: 10px; color: white;"></div>
<head>
    <title>SketchUpæ¨¡å‹é¢„è§ˆ</title>
    <style>
        body { 
            margin: 0;          /* å»é™¤é¡µé¢é»˜è®¤è¾¹è· */
            overflow: hidden;   /* éšè—æ»šåŠ¨æ¡ */
        }
        canvas { 
            display: block; 
        }
    </style>
</head>
<body>
    <!-- å¼•å…¥Three.jsåº“ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- å¼•å…¥OrbitControlsï¼ˆæ‘„åƒæœºæ§åˆ¶æ’ä»¶ï¼‰ -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <!-- å¼•å…¥GLTFLoader -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <!-- æ–°å¢UIæŒ‰é’® -->
    <div style="position: fixed; top: 50px; left: 10px; z-index: 100;">
        <button onclick="resetCamera()">é‡ç½®è§†è§’</button>
        <button onclick="toggleWireframe()">åˆ‡æ¢çº¿æ¡†æ¨¡å¼</button>
    </div>
    <div id="info" style="position: fixed; top: 50px; left: 10px; color: white;"></div>

    <script>
        // å…¨å±€å˜é‡å®šä¹‰
        let scene, camera, renderer, controls, gltfModel;// ç”¨äºä¿å­˜åŠ è½½çš„æ¨¡å‹å¼•ç”¨

        // åˆå§‹åŒ–å‡½æ•°
        function init() {
            // 1. åˆ›å»ºåœºæ™¯ã€ç›¸æœºã€æ¸²æŸ“å™¨
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(
                75,                                   // è§†è§’
                window.innerWidth / window.innerHeight, // å®½é«˜æ¯”
                0.1,                                  // è¿‘è£å‰ªé¢
                1000                                  // è¿œè£å‰ªé¢
            );
            renderer = new THREE.WebGLRenderer({ 
                antialias: true                      // å¼€å¯æŠ—é”¯é½¿
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // 2. æ·»åŠ å…‰æºï¼ˆå¦åˆ™æ¨¡å‹å¯èƒ½æ˜¾ç¤ºä¸ºé»‘è‰²ï¼‰
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 5, 5);
            scene.add(directionalLight);

            // 3. åŠ è½½æ¨¡å‹
            const loader = new THREE.GLTFLoader();
            loader.load(
                'model.glb', // æ¨¡å‹è·¯å¾„ï¼ˆç¡®ä¿æ–‡ä»¶åä¸ä½ çš„æ¨¡å‹ä¸€è‡´ï¼ï¼‰
                (gltf) => {
                    gltfModel = gltf.scene; // ä¿å­˜æ¨¡å‹å¼•ç”¨
                    // --- è‡ªåŠ¨é€‚é…æ¨¡å‹å°ºå¯¸ ---
                    scene.add(gltf.scene);
                    // è®¡ç®—æ¨¡å‹åŒ…å›´ç›’
                    const box = new THREE.Box3().setFromObject(gltf.scene);
                    const center = box.getCenter(new THREE.Vector3());
                    const size = box.getSize(new THREE.Vector3());
                    console.log("æ¨¡å‹å°ºå¯¸ï¼š", size);

                    // è‡ªåŠ¨è°ƒæ•´ç›¸æœºä½ç½®å’Œæ§åˆ¶å™¨ç„¦ç‚¹
                    camera.position.copy(center);
                    camera.position.z += size.length() * 1.5; // æ ¹æ®æ¨¡å‹å¤§å°è°ƒæ•´è·ç¦»
                    controls.target.copy(center); // è®©æ“ä½œç„¦ç‚¹å¯¹å‡†æ¨¡å‹ä¸­å¿ƒ
                    console.log("æ¨¡å‹åŠ è½½æˆåŠŸï¼");
                    // --- ç‚¹å‡»äº‹ä»¶ç›‘å¬ï¼ˆæ›´æ–°ç‰ˆï¼‰---
                    renderer.domElement.addEventListener('click', (event) => {
                        const mouse = new THREE.Vector2();
                        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

                        const raycaster = new THREE.Raycaster();
                        raycaster.setFromCamera(mouse, camera);
                        
                        const intersects = raycaster.intersectObjects(gltf.scene.children, true);
                        
                        if (intersects.length > 0) {
                            const clickedObject = intersects[0].object;
                            showObjectInfo(clickedObject); // æ˜¾ç¤ºä¿¡æ¯
                        }
                        
                    });
                    
                    // æ˜¾ç¤ºæ¨¡å‹è¾¹ç•Œæ¡†
                    const boxHelper = new THREE.BoxHelper(gltf.scene, 0x00ff00);
                    scene.add(boxHelper);
                },
                (progress) => {
                    console.log(`åŠ è½½è¿›åº¦ï¼š${(progress.loaded / progress.total * 100).toFixed(2)}%`);
                },
                (error) => {
                    console.error("æ¨¡å‹åŠ è½½å¤±è´¥:", error);
                }
            );

            // 4. è®¾ç½®ç›¸æœºåˆå§‹ä½ç½®
            camera.position.set(0, 2, 5); // (x, y, z)

            // 5. æ·»åŠ äº¤äº’æ§åˆ¶
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;   // å¯ç”¨é˜»å°¼ï¼ˆæ›´æµç•…çš„æ“ä½œï¼‰
            controls.dampingFactor = 0.05;

            // 6. çª—å£å¤§å°å˜åŒ–å“åº”
            window.addEventListener('resize', onWindowResize, false);
        }

        // çª—å£å¤§å°å˜åŒ–å›è°ƒå‡½æ•°
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // åŠ¨ç”»å¾ªç¯
        function animate() {
            requestAnimationFrame(animate);
            controls.update(); // ä»…å½“å¯ç”¨é˜»å°¼æ—¶éœ€è¦
            renderer.render(scene, camera);
        }

        // --- æ–°å¢UIæŒ‰é’®çš„å›è°ƒå‡½æ•° ---
        function resetCamera() {
            controls.reset(); // é‡ç½®è§†è§’
            camera.position.copy(center); // å¦‚æœä¹‹å‰æœ‰è‡ªåŠ¨é€‚é…ä»£ç ä¸­çš„centerå˜é‡
            camera.position.z += size.length() * 1.5;
        }

        function toggleWireframe() {
            gltfModel.traverse((child) => {
                if (child.isMesh) {
                    child.material.wireframe = !child.material.wireframe;
                }
            });
            document.getElementById('info').innerText = 
                `çº¿æ¡†æ¨¡å¼ï¼š${gltfModel.children[0].material.wireframe ? 'å¼€å¯' : 'å…³é—­'}`;
        }
        // æ¨¡å‹éƒ¨ä»¶æ˜¾éšæ§åˆ¶
        function togglePart(partName) {
            gltfModel.traverse((child) => {
                 if (child.name === partName) {
                      child.visible = !child.visible;
                    }
                });
            }
            let highlightedObject = null;

            function showObjectInfo(object) {
                // ç§»é™¤æ—§é«˜äº®
                if (highlightedObject) {
                     highlightedObject.material.emissive?.setHex(0x000000);
                }

                // æ·»åŠ æ–°é«˜äº®
                 if (object.material) {
                    object.material.emissive?.setHex(0xFF0000); // çº¢è‰²é«˜äº®
                    highlightedObject = object;
                     }
            }
            // --- æ–°å¢æ¨¡å‹ä¸Šä¼ åŠŸèƒ½ ---
            function loadNewModel(file) {
                 if (!file) return;

                const loader = new THREE.GLTFLoader();
                const reader = new FileReader();
    
                reader.onload = (event) => {
                    // 1. æ¸…é™¤æ—§æ¨¡å‹åŠå…¶ç›¸å…³èµ„æº
                     if (gltfModel) {
                        scene.remove(gltfModel);
                        disposeHierarchy(gltfModel); // é‡Šæ”¾å†…å­˜
                    }

                     // 2. åŠ è½½æ–°æ¨¡å‹
                    loader.parse(
                        event.target.result,
                         '',
                        (gltf) => {
                            gltfModel = gltf.scene;
                            scene.add(gltfModel);
                            // 3. é€‚é…ç›¸æœºè§†è§’
                            fitCameraToModel(gltfModel);
                            // 4. é‡æ–°ç»‘å®šäº¤äº’äº‹ä»¶
                            bindModelInteractions(gltfModel);
                        },
                        (error) => {
                            console.error("æ¨¡å‹åŠ è½½å¤±è´¥:", error);
                        }
                    );
                };
                reader.onerror = (error) => {
        console.error("æ–‡ä»¶è¯»å–å¤±è´¥:", error);
        };

    reader.readAsArrayBuffer(file);
            // ä¿¡æ¯å±•ç¤ºå‡½æ•°
                // 1. æŸ¥æ‰¾æœ‰æ•ˆåç§°ï¼ˆå¯èƒ½çˆ¶çº§æœ‰åç§°ï¼‰    
                let target = object;
                while (target && !target.name) {
                    target = target.parent;
                }
                const name = target?.name || "æœªå‘½åç‰©ä½“";

                // 2. è·å–æè´¨ä¿¡æ¯
                const materials = [];
                if (object.material) {
                    if (Array.isArray(object.material)) {
                         materials.push(...object.material.map(mat => mat.type));
                     } else {
                         materials.push(object.material.type);
                     }
                }

                // 3. è®¡ç®—åŒ…å›´ç›’å°ºå¯¸
                const bbox = new THREE.Box3().setFromObject(object);
                const size = new THREE.Vector3();
                bbox.getSize(size);
                const dimensions = `å®½: ${size.x.toFixed(2)}m, é«˜: ${size.y.toFixed(2)}m, æ·±: ${size.z.toFixed(2)}m`;

                // 4. æ„å»ºHTMLå†…å®¹
                const content = `
                    <p><strong>åç§°:</strong> ${name}</p>
                    <p><strong>æè´¨:</strong> ${materials.join(', ')}</p>
                    <p><strong>å°ºå¯¸:</strong> ${dimensions}</p>
                    <!-- æ–°å¢è‡ªå®šä¹‰å…ƒæ•°æ® -->
                     ${object.userData.materialType ? `<p><strong>ææ–™ç±»å‹:</strong> ${object.userData.materialType}</p>` : ''}
                     ${object.userData.price ? `<p><strong>ä»·æ ¼:</strong> ${object.userData.price}å…ƒ</p>` : ''}
                `;

                // 5. æ›´æ–°UI
                const infoPanel = document.getElementById('info-panel');
                const infoContent = document.getElementById('info-content');
                infoContent.innerHTML = content;
                infoPanel.style.display = 'block';

                // 6. 5ç§’åè‡ªåŠ¨éšè—
                clearTimeout(infoPanel.timeout);
                infoPanel.timeout = setTimeout(() => {
                    infoPanel.style.display = 'none';
                }, 5000);
                // æ–°å¢è¾…åŠ©å‡½æ•°
function fitCameraToModel(model) {
    const box = new THREE.Box3().setFromObject(model);
    const center = box.getCenter(new THREE.Vector3());
    const size = box.getSize(new THREE.Vector3());
    
    camera.position.copy(center);
    camera.position.z += size.length() * 1.5;
    controls.target.copy(center);
}

function bindModelInteractions(model) {
    // å…ˆç§»é™¤æ—§çš„ç‚¹å‡»äº‹ä»¶
    renderer.domElement.removeEventListener('click', modelClickHandler);
    
    // å®šä¹‰æ–°çš„äº‹ä»¶å¤„ç†å™¨
    const modelClickHandler = (event) => {
        const mouse = new THREE.Vector2();
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        const raycaster = new THREE.Raycaster();
        raycaster.setFromCamera(mouse, camera);
        
        // å…³é”®ä¿®æ”¹ï¼šæ£€æµ‹æ•´ä¸ªæ¨¡å‹æ ‘ï¼Œå¼€å¯é€’å½’æ£€æµ‹
        const intersects = raycaster.intersectObjects(model.children, true);
        
        if (intersects.length > 0) {
            const clickedObject = intersects[0].object;
            showObjectInfo(clickedObject);
        }
    };

    // ç»‘å®šæ–°äº‹ä»¶
    renderer.domElement.addEventListener('click', modelClickHandler);
}

// ä¿®æ”¹showObjectInfoå¢å¼ºå…¼å®¹æ€§
function showObjectInfo(object) {
    // å®‰å…¨è®¿é—®æè´¨å±æ€§
    const materials = [];
    try {
        if (object.material) {
            materials.push(Array.isArray(object.material) ? 
                object.material.map(m => m?.type || 'æœªçŸ¥æè´¨') : 
                object.material?.type || 'æœªçŸ¥æè´¨');
        }
    } catch (e) {
        console.warn('æè´¨ä¿¡æ¯è¯»å–å¤±è´¥:', e);
    }
}

function disposeHierarchy(node) {
    if (node.isMesh) {
        if (node.geometry) node.geometry.dispose();
        if (node.material) {
            if (Array.isArray(node.material)) {
                node.material.forEach(mat => mat.dispose());
            } else {
                node.material.dispose();
            }
        }
    }
    node.children?.forEach(child => disposeHierarchy(child));
}
            }    
            

        // å¯åŠ¨
        init();
        animate();
        
    </script>
</body>
</html>
